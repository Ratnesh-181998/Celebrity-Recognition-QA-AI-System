# Demo Pic 
>>>>>>>>>>>>>

AI Celebrity Detector and Q/A System

Tech Stack & Tools:
‚Ä¢	Google Cloud
‚Ä¢	Kubernetes
‚Ä¢	CircleCI
‚Ä¢	Flask
‚Ä¢	Python
‚Ä¢	HTML
‚Ä¢	CSS
‚Ä¢	Groq
‚Ä¢	Vision Transformers

>>>>>>>>>>>>>>>

# Arctitecture

AI Celebrity Detector & Q/A System ‚Äì Architecture Flow
1Ô∏è‚É£ Development Setup
‚Ä¢	Project and API Setup
‚Ä¢	Image Handler Code
‚Ä¢	Celebrity Detector Code
‚Ä¢	Q/A Engine Code
‚Ä¢	Routes Code
‚Ä¢	Application Code
________________________________________
2Ô∏è‚É£ Containerization & Deployment
‚Ä¢	Dockerfile
‚Ä¢	Kubernetes Deployment File
________________________________________
3Ô∏è‚É£ Version Control & CI/CD
‚Ä¢	Code Versioning using GitHub
‚Ä¢	CircleCI Pipeline
‚Ä¢	Build and Push Image to Google Artifact Registry (GAR)
‚Ä¢	Deploy to Google Kubernetes Engine (GKE)
________________________________________
4Ô∏è‚É£ Production Environment
‚Ä¢	Deployed Application on GKE

>>>>>>>>>>>
Project Explaination 

step-by-step explanation of your AI Celebrity Detector & Q/A System, followed by a step-by-step architecture diagram explanation (both logical flow and deployment flow).________________________________________
üîπ Part 1: Step-by-Step Working Explanation (End-to-End)
Step 1Ô∏è‚É£ User Interaction (Frontend)
‚Ä¢	The user opens the web application built with HTML/CSS.
‚Ä¢	User:
o	Uploads an image (celebrity photo)
o	Asks a question related to the image (e.g., ‚ÄúWho is this?‚Äù, ‚ÄúWhich movies has this person acted in?‚Äù)
üìå Frontend sends:
‚Ä¢	Image ‚Üí backend
‚Ä¢	Question ‚Üí backend API
________________________________________
Step 2Ô∏è‚É£ Flask Backend Receives Request
‚Ä¢	Flask acts as the backend API layer.
‚Ä¢	Flask endpoint:
o	Accepts image file
o	Accepts text question
o	Routes request to internal services
üìå Responsibilities:
‚Ä¢	Input validation
‚Ä¢	Request routing
‚Ä¢	Response formatting (JSON / UI-friendly)
________________________________________
Step 3Ô∏è‚É£ Image Preprocessing (OpenCV)
‚Ä¢	Uploaded image is passed to OpenCV (Python).
‚Ä¢	OpenCV performs:
o	Image resizing
o	Format conversion (RGB, tensor-ready)
o	Normalization
üìå Output:
‚Ä¢	Clean, optimized image tensor ready for ML inference
________________________________________
Step 4Ô∏è‚É£ Celebrity Detection (Vision Transformer)
‚Ä¢	Preprocessed image is sent to Vision Transformer model.
‚Ä¢	The model:
o	Extracts facial and visual embeddings
o	Matches against known celebrity representations
o	Identifies the most likely celebrity
üìå Output:
‚Ä¢	Detected celebrity name
‚Ä¢	Confidence score (optional)
________________________________________
Step 5Ô∏è‚É£ Multimodal Q/A using Groq LLM
‚Ä¢	The system now combines:
o	Detected celebrity
o	User‚Äôs question
‚Ä¢	These are passed to Groq (LLaMA-4 Vision LLM).
Groq performs:
‚Ä¢	Multimodal reasoning (image + text)
‚Ä¢	Context-aware answer generation
üìå Example:
Input: Image + ‚ÄúWho is this and what are they famous for?‚Äù
Output: ‚ÄúThis is Shah Rukh Khan, a renowned Indian actor known for‚Ä¶‚Äù
________________________________________
Step 6Ô∏è‚É£ Response Returned to User
‚Ä¢	Flask sends the final response back to the frontend.
‚Ä¢	UI displays:
o	Celebrity name
o	Answer to the user‚Äôs question
‚úÖ End-user gets real-time AI-powered insight
________________________________________
üîπ Part 2: Architecture Diagram (Logical Flow ‚Äì Step by Step)
[ User Browser ]
       |
       v
[ HTML / CSS UI ]
       |
       v
[ Flask API Layer ]
       |
       v
[ OpenCV Image Processing ]
       |
       v
[ Vision Transformer ]
       |
       v
[ Groq LLM (LLaMA-4 Vision) ]
       |
       v
[ Answer Generated ]
       |
       v
[ Response to UI ]
________________________________________
üîπ Part 3: CI/CD & Deployment Architecture (Step by Step)
Step 1Ô∏è‚É£ Code Versioning
‚Ä¢	All code is maintained in GitHub
‚Ä¢	Includes:
o	Backend code
o	ML logic
o	Dockerfile
o	Kubernetes manifests
________________________________________
Step 2Ô∏è‚É£ CI/CD Pipeline (CircleCI)
‚Ä¢	On every push to GitHub:
o	CircleCI pipeline is triggered
o	Runs tests (optional)
o	Builds Docker image
________________________________________
Step 3Ô∏è‚É£ Containerization (Docker)
‚Ä¢	Application is packaged into a Docker image
‚Ä¢	Ensures:
o	Same environment everywhere
o	Easy scaling and deployment
________________________________________
Step 4Ô∏è‚É£ Image Storage (GCP Artifact Registry)
‚Ä¢	Built Docker image is pushed to:
o	Google Cloud Artifact Registry (GAR)
________________________________________
Step 5Ô∏è‚É£ Kubernetes Deployment (GKE)
‚Ä¢	Kubernetes deployment YAML:
o	Pulls image from GAR
o	Creates pods
o	Exposes service
‚Ä¢	Application runs on Google Kubernetes Engine (GKE)
________________________________________
Step 6Ô∏è‚É£ Production Access
‚Ä¢	Users access the deployed application via:
o	LoadBalancer / Ingress
o	Public cloud endpoint
________________________________________
üîπ CI/CD + Cloud Architecture Diagram
[ Developer ]
     |
     v
[ GitHub Repository ]
     |
     v
[ CircleCI Pipeline ]
     |
     v
[ Docker Build ]
     |
     v
[ GCP Artifact Registry ]
     |
     v
[ Google Kubernetes Engine ]
     |
     v
[ Live AI Application ]
________________________________________
üîπ One-Line Summary (Very Important)
‚ÄúThis system uses a Vision Transformer for celebrity detection, Groq‚Äôs multimodal LLM for contextual Q&A, Flask for backend orchestration, OpenCV for image preprocessing, and is deployed on GKE using Docker and CircleCI-based CI/CD pipelines.‚Äù

